# トピックス

(以下、どこかに書くべきことをいったんここに書いてある。説明として分かりやすくはない)

## 設計面

### プロジェクト

- `include` によって結合される一連のファイルを **プロジェクト** (project) と呼ぶことにしている
    (EDIT: この定義は取り下げるかもしれない)
- アナライザが扱う全体のことを **ワークスペース** (workspace) と呼ぶことにしている
- データベースレイヤーのアナリシスは、ドキュメントごと、プロジェクトごと、ワークスペースごとに、解析結果のデータを分割して持っている
    (`DocAnalysis`, `ProjectAnalysis`, `WorkspaceAnalysis`)
    - スクリプトの変更の際に、そのスクリプト以外のドキュメントごとの解析結果は影響を受けないので、再解析を省ける。プロジェクトについても同様。(ワークスペースは常に影響を受ける)

### `common`

- HSPのインストールフォルダに `common` フォルダがあり、ここに標準のモジュールなどが置かれている
- HAMは起動時にこれらのスクリプトをすべて収集している
    - アナライザへの入力の一部とみなされる

### `hsphelp`

- HSPのインストールフォルダに `hsphelp` フォルダがあり、ここに組み込み命令の説明などが書かれた **ヘルプファイル** (.hs) がある。
    スクリプトエディタで「F1」キーを押すと表示される説明やサンプルはこれらのファイルがもとになっている。
    詳細はHSPのインストールフォルダの `doclib/HSP Doc Library` にあるファイルを参照
- HAMは起動時にヘルプファイルをすべて収集している
    - アナライザへの入力の一部とみなされる
    - シグネチャヘルプの実装に使われている

### トリビアトークン

- HAMの字句解析では、空白やコメントもトークンとみなす。これらのトークンを **トリビア** (trivia) と呼んでいる
    - 文脈: 典型的なコンパイラの教科書では空白やコメントをトークンとみなさない。コンパイラはコメントを無視するのでそれでいい
    - 理由: アナライザでは、コメントに書かれている内容を後で参照したり、コードアクション (スクリプトの内容の変更を提案する操作) があるため、念のためトークンとして残している (これはrust-analyzerの設計を参考にした)
- HAMの構文解析では、構文トークン (`PToken`) という概念を導入する
    - 理由: トークン列の中にトリビアが挟まっていると、構文解析の先読みで邪魔になる
    - トリビアとその周囲のトークンをまとめて1個の構文トークンに固める
        - これによって構文解析中の先読みにトリビアは影響しなくなる

### パーサー

- 手書きの再帰下降構文解析 (LL法) を使っている
- プリプロセッサ (`#` のある行) とそれ以外 (地の文) を分けずにパースしている
- 演算子の結合 (優先順位) を無視している
    - いま実装済みのIDE機能においては支障がないはず
- うまくパースできない場面があり、適当なヒューリスティック (厳密には誤っているが、実際に与えられるスクリプトに対してはたいていうまくいくだろう方法) でしのいでいる
    - 名前が命令として定義済みかどうかで曖昧になることがあるため

----

## コマンド

CLIコマンドで機能を部分的に実行できるようになっている (`ham.exe`, 実装は `ham-core/src/bin/ham.rs`)

### `parse`: 構文木の文字列表示

```sh
cargo run --bin ham parse hsed3-ext/app_main.hsp >output.txt
```

### `format-comments`: コメント形式の変更 (`//` → `;`)

**注意**: ファイルは上書きされます。実行前に必ずバックアップを用意してください

自分用に作ったコマンド。
HSPのスクリプト (UTF-8) のコメントのスタイルを変更する

使用例:

```
EXAMPLE:
    (1)
        {name} a.hsp b.hsp c.hsp

    (2)
        cat input.hsp | {name} - >output.hsp
```

動作例:

```hsp
; コメント
```

↓

```
// コメント
```

### LSPサーバーの環境変数による設定

- `HAM_LINT` (既定値 `1`): `1` なら、リントを有効化する
- `HAM_WATCHER_ENABLED` (既定値 `1`): `1` なら、ファイルウォッチャーを有効化する (既定値 `1`)

## テスト

```sh
cargo test

# HSPのファイルを参照するコードを含むテスト
# (実行時に環境変数 HSP3_ROOT にHSP3のインストールディレクトリへのパスを指定する必要がある)
# parse_testsはfailing
cargo test --features full_test
```

### `expect`

スナップショットテストのため [expect-test](https://github.com/rust-analyzer/expect-test) というクレートを使っている。
**スナップショットテスト** とは入力データとその計算結果が一致することを確認すること

使いかたは `expect!` でソースコード内を検索するとみつかる。
はじめは `expect![[""]]` とだけ書いておいて、次のように計算結果を更新すると楽

```sh
UPDATE_EXPECT=1 cargo test
```

----

## 課題など

### マクロ機能がないこと

マクロ機能を実装する上で「エントリーポイントが未確定であること」という課題がある

- マクロ機能は「上から下へ」解析する必要がある
    - マクロの定義は `#define` によって追加され、`#undef` によって消される
    - `#if` などの分岐の解釈は、その時点で定義されているマクロによる
    - ファイルは `#include` によって結合して使われることがある。その場合、そのincludeの使用箇所において定義されているマクロが、そのスクリプトファイルの先頭においても定義されていることになる
        - 同じスクリプトファイルが複数個所でincludeされていて、そこで定義されているマクロが異なるおそれがある
- 直接実行されるスクリプトを **エントリーポイント** (入口) と呼ぶことにする
    - スクリプトエディタで開いて F5 (実行) を押すときのファイルのこと
    - 一方、それ以外のファイルは `#include` などの命令によって間接的に使用される
- ファイルを開いていてIDE機能を使う時点で、どのスクリプトがエントリーポイントであるかは確定していない
    - そのスクリプト自身がエントリーポイントかもしれない。
        ほかのスクリプトを実行するときに間接的にincludeされるのかもしれない
    - エントリーポイントは複数ありうる
        (例えば汎用的なモジュールがあって、それをアプリAとアプリBの両方からincludeする状況はありうる)
        - この状況で `rename` や `references` などの「シンボルの使用箇所を検索する」機能の結果には、アプリA/B両方が含まれるはず
- 単純な解決策は、すべてのスクリプトをエントリーポイントとみなして、そこから解析を行うこと
    - それぞれのスクリプトについて、それをエントリーポイントであると仮定して解析を行う
        - 一連の解析にはincludeによって複数のスクリプトが含まれうる。
            逆にいうと、スクリプトファイルごとに、それを解析中に使うようなエントリーポイントは複数ありうる
    - 特定のファイルに対してIDE機能を使うとする。
        この時点で、そのファイルを解析に含むことになるエントリーポイントが複数ありうる
        - それぞれのエントリーポイントごとにIDE機能の解析処理を適用して、その結果から冗長性を取り除いて集約する
    - (課題):
        - 結果を集約する方法を検討する必要がある
        - 計算コストが高そうにみえる (測ってはいない)
    - `diagnose` をどうするのか
        - ユーザーが想定していないエントリーポイントでは、シンボルが未定義などのエラーが発生することが多い。
        これらのエラーは報告しても意味がない
        (いま実装済みの診断については問題ないかもしれない)
- 計算量的にスマートだが不正確な解決策の一案:
    ファイル間の `include` の流れをあらかじめ計算する。
    IDE機能の対象となるファイルからさかのぼって、それを間接的にincludeする可能性があるエントリーポイントを列挙する。
    それぞれのエントリーポイントからマクロ展開処理を行って、実際に指定ファイルをincludeしたものを選別し、それぞれにIDE機能を適用して、結果を集約する
    - 結局、結果を集約する方法を検討する必要がある
    - `include` のファイル名がマクロで指定されていると解決が不可能なので、諦めることになる

例:

```hsp
; file: mod_x.hsp
#ifdef DEFINE_A
    #deffunc a
#else
    #deffunc b
#endif

; file: a.hsp
#define DEFINE_A
#include "mod_x.hsp"  ; defines a

; file: b.hsp
#include "mod_x.hsp"  ; defines b
```
