# アーキテクチャ

(WIP)

(**HAM** は `hsp3-analyzer-mini` 自身のこと)

これは「HAMのコードベースへの理解」を助けることを目的として書かれている

## 前提知識

- HSP、HAMの基本的な使いかた
- インタプリタまたはコンパイラの基本的な仕組み、作りかた
- ほか

## アナライザ

- HAMのようなソフトウェアを **アナライザ** (analyzer) と呼ぶことにする
- アナライザは言語処理系の一種で、エディタ内でのホバー表示や入力補完などの機能を提供するソフトウェアである
- アナライザが提供するそれらの機能を総称的に **IDE機能** と呼ぶことにする

### アナライザの入出力

- アナライザは **入力** としてスクリプトと、そのスクリプトの意味に関する質問を受け取り、質問への回答を **出力** するものである
- 例:
    - ホバー表示でいえば、質問は「`main.hsp` の8行目・4文字目にある `foo` という単語は何？」といったもの
    - アナライザは「この `foo` はdeffuncで定義された命令である」と応答できる
- アナライザはスクリプトに関する問い合わせシステムであるといえる

### LSP

- **LSP** (language server protocol) はエディタ (VSCode) とアナライザをつなぐための仕組み
- ユーザーの操作によって、エディタはIDE機能を作動させる。エディタはその処理のためにアナライザに問い合わせを行う
    - (エディタにプログラミング言語固有の機能を持たせるわけにはいかないため)
- LSPという仕様では、エディタがアナライザにどう問い合わせるか、アナライザがそれにどう応答するか、を定められている

----

## HAMの内部構造

- HAMの内部構造は大きく分けて以下のパーツからなる
    - 字句解析・構文解析
    - 意味解析
    - データベースレイヤー
    - IDE機能
    - LSPサーバー

### 字句解析・構文解析

- (ここはインタプリタやコンパイラと同様)
- スクリプトを **字句解析** (tokenize) してトークン列 (tokens) に変換する
- トークン列を **構文解析** (parse) して **解析木** (parse tree) に変換する
- IDE機能に使うため、位置情報 (location) を正確に保持している

### 意味解析

- (ここはインタプリタやコンパイラと同様)
- 解析木に **意味解析** を行い、**シンボル** (symbol) や **スコープ** (scope) の情報を収集する
    - **シンボル** (symbol) はスクリプト内で定義されている名前のこと (変数やラベル、命令など)

### データベースレイヤー

- (これは仮の呼称。このパーツのことを何と呼ぶべきか分からない)
- HAMは実行中に以下の2つのデータを保持している
- 1つ目:
    - HAMが扱うスクリプトは、ファイルに保存されているものと、エディタ内で編集中のものがある。これらを総称して **ドキュメント** (document) と呼ぶ
    - HAMは全ドキュメントのデータを保持している
        - ファイルの内容を保持しているのは、ファイルの読み込みにかかる時間を省くため
        - 「エディタ内の編集中のデータ」は、アナライザから問い合わせて取得することができず、エディタから送られてくるものであるため
- 2つ目:
    - 解析結果を表すデータ構造を **アナリシス** (analysis) と呼んでいる
    - HAMは意味解析の結果の一部をキャッシュとして保持している。これは効率を改善するため
- 効率の話:
    - エディタ上でキー入力されるたびに、スクリプトの変更とIDE機能の処理要求が発生する。これはかなりの高頻度である
    - 一連の解析処理を毎回、最初から行うのは非効率である。たいていの場合、スクリプトの変更は1行の追加や削除で、解析処理の大部分は変化しないため
    - 解析処理の結果を記憶 (キャッシュ) しておき、変更の影響を受けなかった部分の再解析をある程度防ぐように、データ構造が設計されている

### IDE機能

- アナリシスを使って、ホバー表示や入力補完などの個別のIDE機能が実装されている

### LSPサーバー

- **LSPサーバー** (LSP server) は、LSP仕様にしたがって動作するプロセスで、エディタとアナライザが対話するためのもの

----

## ウォークスルー

実行時の流れを時系列に沿って軽く述べる

### 1. 初期化

はじめに初期化が行われる

- エディタ(VSCode)によってHAMの拡張機能が起動(activate)され、そのLSPクライアントがLSPサーバープロセスを起動する
- LSPの仕様にしたがって、エディタがサーバーに `initialize` リクエストを送り、サーバーがレスポンスを返す
- サーバーは初期データの読み込みを行う (common, hsphelp, ワークスペース内のスクリプト)

#### 2. (例1) `references`

エディタでシンボルにカーソルを合わせ、「すべての参照を検索」を行ったとする

- エディタがサーバーに `references` リクエストを送る (ドキュメントのURIと行番号・列番号が含まれる)
- サーバーがそのリクエストを受け取り、`lsp_handler` で `text_document_references` 関数が呼ばれる
- 処理の本体は `assists/references.rs` にある
- 指定したドキュメントに関連するプロジェクトの解析結果 (ProjectAnalysis) を取得する
    - このときプロジェクトに対して解析処理が行われる
        (この解析結果は次にそのプロジェクトに変更があるまで保持される)
- そのドキュメントの指定された位置にあるシンボルを特定する (`locate_symbol`)
    - プロジェクト内にある全シンボルのすべての定義箇所、使用箇所は解析結果に含まれている。
        これらの中から指定位置にあるものを探す
- このシンボルの使用箇所の列挙を行う
    - 解析結果が持っている使用箇所の一覧を、そのシンボルで絞り込めばいい
    - (`references` の具体的な挙動はほかにもあるかもしれないが、ここでは省略)
- 最後に収集したデータをLSP仕様に沿うかたちに変換して返す
- `lsp_handler` がそのデータをレスポンスとしてエディタに送る

#### 3. (例2) `didChange`

エディタで編集中のスクリプトにキー入力をしたとする

- エディタがドキュメントの変更 (`didChange`) をサーバーに送る
- サーバーはそのリクエストを受け取って、`lsp_handler` で `text_document_did_change` 関数が呼ばれる
- `docs` (ドキュメントストア) に変更後のデータが記録される
    - この時点では再解析は行われない
    - この変更によって再解析が必要となるデータの解析結果が削除される
    - 次に (`references` などのリクエストで) プロジェクトの解析結果が必要となったときに、あらためて解析が行われる

#### 4. 終了

エディタが閉じるときなどに終了処理が行われる。
LSPサーバーが終了時に行う処理は特にないため、この流れはあまり重要ではない

- エディタが拡張機能を停止(deactivate)し、そこでLSPクライアントが停止される
- LSPの仕様により、まずクライアントはLSPサーバーに `shutdown` リクエストを送る
    - LSPサーバーが `shutdown` リクエストにレスポンスする (サーバー側では特に何も起きない)
- クライアントが `exit` 通知を送り、サーバーが自発的に終了する

----

> [ARCHITECTURE.md](https://matklad.github.io/2021/02/06/ARCHITECTURE.md.html)
