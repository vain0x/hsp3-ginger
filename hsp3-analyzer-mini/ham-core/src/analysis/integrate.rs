#[cfg(test)]
mod tests {
    use crate::{
        analysis::*,
        source::{DocId, Pos},
    };

    /// `<|x|>` のようなマーカーを含む文字列を受け取る。間に挟まれている x の部分をマーカーの名前と呼ぶ。
    /// マーカーを取り除いた文字列 text と、text の中でマーカーが指している位置のリストを返す。
    fn parse_cursor_string(s: &str) -> (String, Vec<(&str, Pos)>) {
        let mut output = vec![];

        let mut text = String::with_capacity(s.len());
        let mut pos = Pos::default();
        let mut i = 0;

        while let Some(offset) = s[i..].find("<|") {
            // カーソルを <| の手前まで進める。
            let j = i + offset;
            text += &s[i..j];
            pos += Pos::from(&s[i..j]);
            i += offset + "<|".len();

            // <| と |> の間を名前として取る。
            let name_len = s[i..].find("|>").expect("missing |>");
            let j = i + name_len;
            let name = &s[i..j];
            i += name_len + "|>".len();

            output.push((name, pos));
        }

        text += &s[i..];
        (text, output)
    }

    #[test]
    fn test_locate_static_var_def() {
        let mut wa = WorkspaceAnalysis::default();
        wa.initialize(WorkspaceHost::default());

        let doc: DocId = 1;
        let text = r#"
            <|A|>foo = 1
        "#;
        let expected_map = vec![("A", Some("foo"))]
            .into_iter()
            .collect::<HashMap<_, _>>();
        let (text, cursors) = parse_cursor_string(text);

        wa.update_doc(doc, Lang::Hsp3, text.into());

        wa.ensure_computed();
        let p = wa.require_project_for_doc(doc);

        for (name, pos) in cursors {
            let actual = p
                .locate_symbol(doc, pos.into())
                .map(|(symbol, _)| symbol.name());
            assert_eq!(actual.as_deref(), expected_map[name], "name={}", name);
        }
    }

    #[test]
    fn test_it_works() {
        let mut wa = WorkspaceAnalysis::default();
        wa.initialize(WorkspaceHost::default());

        let doc: DocId = 1;
        let text = r#"
            #module
            #deffunc <|A|>hello
                mes "Hello, world!"
                return
            #global

                <|B|>hello
                hello<|C|> <|D|>
        "#;
        let expected_map = vec![
            ("A", Some("hello")),
            ("B", Some("hello")),
            ("C", Some("hello")),
            ("D", None),
        ]
        .into_iter()
        .collect::<HashMap<_, _>>();
        let (text, cursors) = parse_cursor_string(text);

        wa.update_doc(doc, Lang::Hsp3, text.into());

        wa.ensure_computed();
        let p = wa.require_project_for_doc(doc);

        for (name, pos) in cursors {
            let actual = p
                .locate_symbol(doc, pos.into())
                .map(|(symbol, _)| symbol.name());
            assert_eq!(actual.as_deref(), expected_map[name], "name={}", name);
        }
    }
}
